"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/challenges/challenge-1",{

/***/ "./components/CodeEditor.jsx":
/*!***********************************!*\
  !*** ./components/CodeEditor.jsx ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _uiw_react_codemirror__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @uiw/react-codemirror */ \"./node_modules/@uiw/react-codemirror/esm/index.js\");\n/* harmony import */ var _replit_codemirror_lang_solidity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @replit/codemirror-lang-solidity */ \"./node_modules/@replit/codemirror-lang-solidity/dist/index.js\");\n\nvar _s = $RefreshSig$();\n\n\n\nfunction Editor(param) {\n    let { initialCode } = param;\n    _s();\n    const [code, setCode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialCode);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"code-editor-container\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_uiw_react_codemirror__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            value: code,\n            height: \"400px\",\n            theme: \"dark\",\n            extensions: [\n                (0,_replit_codemirror_lang_solidity__WEBPACK_IMPORTED_MODULE_3__.solidity)()\n            ],\n            onChange: (newCode)=>setCode(newCode)\n        }, void 0, false, {\n            fileName: \"/Users/jordansolomon/Desktop/Web3/Development/Minds3t-Game/front-end/components/CodeEditor.jsx\",\n            lineNumber: 10,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/jordansolomon/Desktop/Web3/Development/Minds3t-Game/front-end/components/CodeEditor.jsx\",\n        lineNumber: 9,\n        columnNumber: 9\n    }, this);\n}\n_s(Editor, \"ZFV6bPVogXq7gKF6tM763Q/dBFY=\");\n_c = Editor;\nvar _c;\n$RefreshReg$(_c, \"Editor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0NvZGVFZGl0b3IuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFpQztBQUNjO0FBQ1U7QUFFbEQsU0FBU0csT0FBTyxLQUFlO1FBQWYsRUFBRUMsV0FBVyxFQUFFLEdBQWY7O0lBQ25CLE1BQU0sQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHTiwrQ0FBUUEsQ0FBQ0k7SUFFakMscUJBQ0ksOERBQUNHO1FBQUlDLFdBQVU7a0JBQ1gsNEVBQUNQLDZEQUFVQTtZQUNQUSxPQUFPSjtZQUNQSyxRQUFPO1lBQ1BDLE9BQU07WUFDTkMsWUFBWTtnQkFBQ1YsMEVBQVFBO2FBQUc7WUFDeEJXLFVBQVUsQ0FBQ0MsVUFBWVIsUUFBUVE7Ozs7Ozs7Ozs7O0FBSS9DO0dBZGdCWDtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvcmRhbnNvbG9tb24vRGVza3RvcC9XZWIzL0RldmVsb3BtZW50L01pbmRzM3QtR2FtZS9mcm9udC1lbmQvY29tcG9uZW50cy9Db2RlRWRpdG9yLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IENvZGVNaXJyb3IgZnJvbSBcIkB1aXcvcmVhY3QtY29kZW1pcnJvclwiO1xuaW1wb3J0IHtzb2xpZGl0eX0gZnJvbSBcIkByZXBsaXQvY29kZW1pcnJvci1sYW5nLXNvbGlkaXR5XCJcblxuZXhwb3J0IGZ1bmN0aW9uIEVkaXRvcih7IGluaXRpYWxDb2RlIH0pIHtcbiAgICBjb25zdCBbY29kZSwgc2V0Q29kZV0gPSB1c2VTdGF0ZShpbml0aWFsQ29kZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvZGUtZWRpdG9yLWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPENvZGVNaXJyb3JcbiAgICAgICAgICAgICAgICB2YWx1ZT17Y29kZX1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9XCI0MDBweFwiXG4gICAgICAgICAgICAgICAgdGhlbWU9XCJkYXJrXCJcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zPXtbc29saWRpdHkoKV19XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhuZXdDb2RlKSA9PiBzZXRDb2RlKG5ld0NvZGUpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJDb2RlTWlycm9yIiwic29saWRpdHkiLCJFZGl0b3IiLCJpbml0aWFsQ29kZSIsImNvZGUiLCJzZXRDb2RlIiwiZGl2IiwiY2xhc3NOYW1lIiwidmFsdWUiLCJoZWlnaHQiLCJ0aGVtZSIsImV4dGVuc2lvbnMiLCJvbkNoYW5nZSIsIm5ld0NvZGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/CodeEditor.jsx\n"));

/***/ }),

/***/ "./node_modules/@replit/codemirror-lang-solidity/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@replit/codemirror-lang-solidity/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   solidity: () => (/* binding */ solidity)\n/* harmony export */ });\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/highlight */ \"./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n/**\n* Wrapper around the legacy CM5 Solidity language mode\n* See: https://github.com/alincode/codemirror-solidity\n*/\nconst keywords = {\n    pragma: true,\n    solidity: true,\n    import: true,\n    as: true,\n    from: true,\n    contract: true,\n    constructor: true,\n    is: true,\n    function: true,\n    modifier: true,\n    // modifiers\n    pure: true,\n    view: true,\n    payable: true,\n    constant: true,\n    anonymous: true,\n    indexed: true,\n    returns: true,\n    return: true,\n    event: true,\n    struct: true,\n    mapping: true,\n    interface: true,\n    using: true,\n    library: true,\n    storage: true,\n    memory: true,\n    calldata: true,\n    public: true,\n    private: true,\n    external: true,\n    internal: true,\n    emit: true,\n    assembly: true,\n    abstract: true,\n    after: true,\n    catch: true,\n    final: true,\n    in: true,\n    inline: true,\n    let: true,\n    match: true,\n    null: true,\n    of: true,\n    relocatable: true,\n    static: true,\n    try: true,\n    typeof: true,\n    var: true,\n};\nconst keywordsSpecial = {\n    pragma: true,\n    returns: true,\n    address: true,\n    contract: true,\n    function: true,\n    struct: true,\n};\nconst keywordsEtherUnit = {\n    wei: true,\n    szabo: true,\n    finney: true,\n    ether: true,\n};\nconst keywordsTimeUnit = {\n    seconds: true,\n    minutes: true,\n    hours: true,\n    days: true,\n    weeks: true,\n};\nconst keywordsBlockAndTransactionProperties = {\n    block: ['coinbase', 'difficulty', 'gaslimit', 'number', 'timestamp'],\n    msg: ['data', 'sender', 'sig', 'value'],\n    tx: ['gasprice', 'origin'],\n};\nconst keywordsMoreBlockAndTransactionProperties = {\n    now: true,\n    gasleft: true,\n    blockhash: true,\n};\nconst keywordsErrorHandling = {\n    assert: true,\n    require: true,\n    revert: true,\n    throw: true,\n};\nconst keywordsMathematicalAndCryptographicFuctions = {\n    addmod: true,\n    mulmod: true,\n    keccak256: true,\n    sha256: true,\n    ripemd160: true,\n    ecrecover: true,\n};\nconst keywordsContractRelated = {\n    this: true,\n    selfdestruct: true,\n    super: true,\n};\nconst keywordsTypeInformation = { type: true };\nconst keywordsContractList = {};\nconst keywordsControlStructures = {\n    if: true,\n    else: true,\n    while: true,\n    do: true,\n    for: true,\n    break: true,\n    continue: true,\n    switch: true,\n    case: true,\n    default: true,\n};\nconst keywordsValueTypes = {\n    bool: true,\n    byte: true,\n    string: true,\n    enum: true,\n    address: true,\n};\nconst keywordsV0505NewReserve = {\n    alias: true,\n    apply: true,\n    auto: true,\n    copyof: true,\n    define: true,\n    immutable: true,\n    implements: true,\n    macro: true,\n    mutable: true,\n    override: true,\n    partial: true,\n    promise: true,\n    reference: true,\n    sealed: true,\n    sizeof: true,\n    supports: true,\n    typedef: true,\n    unchecked: true,\n};\nconst keywordsAbiEncodeDecodeFunctions = {\n    abi: [\n        'decode',\n        'encodePacked',\n        'encodeWithSelector',\n        'encodeWithSignature',\n        'encode',\n    ],\n};\nconst keywordsMembersOfAddressType = [\n    'transfer',\n    'send',\n    'balance',\n    'call',\n    'delegatecall',\n    'staticcall',\n];\nconst natSpecTags = ['title', 'author', 'notice', 'dev', 'param', 'return'];\nconst atoms = {\n    delete: true,\n    new: true,\n    true: true,\n    false: true,\n};\nconst isOperatorChar = /[+\\-*&^%:=<>!|/~]/;\nconst isNegativeChar = /[-]/;\nlet curPunc;\nfunction tokenBase(stream, state) {\n    let ch = stream.next();\n    if (ch === '\"' || ch === \"'\" || ch === '`') {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n    }\n    if (isVersion(stream, state)) {\n        return 'version';\n    }\n    if (ch === '.' &&\n        keywordsMembersOfAddressType.some(function (item) {\n            return stream.match(`${item}`);\n        })) {\n        return 'addressFunction';\n    }\n    if (typeof ch === 'string' && isNumber(ch, stream)) {\n        return 'number';\n    }\n    if (typeof ch === 'string' && /[[\\]{}(),;:.]/.test(ch)) {\n        return updateGarmmer(ch, state);\n    }\n    if (ch === '/') {\n        if (stream.eat('*')) {\n            state.tokenize = tokenComment;\n            return tokenComment(stream, state);\n        }\n        if (stream.match(/\\/{2}/)) {\n            ch = stream.next();\n            while (ch) {\n                if (ch === '@') {\n                    stream.backUp(1);\n                    state.grammar = 'doc';\n                    break;\n                }\n                ch = stream.next();\n            }\n            return 'doc';\n        }\n        if (stream.eat('/')) {\n            stream.skipToEnd();\n            return 'comment';\n        }\n    }\n    if (typeof ch === 'string' && isNegativeChar.test(ch)) {\n        const peeked = stream.peek();\n        if (typeof peeked === 'string' && isNumber(peeked, stream)) {\n            return 'number';\n        }\n        return 'operator';\n    }\n    if (typeof ch === 'string' && isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return 'operator';\n    }\n    stream.eatWhile(/[\\w$_\\xa1-\\uffff]/);\n    const cur = stream.current();\n    if (state.grammar === 'doc') {\n        if (natSpecTags.some(function (item) {\n            return cur === `@${item}`;\n        })) {\n            return 'docReserve';\n        }\n        return 'doc';\n    }\n    if (cur === 'solidity' && state.lastToken === 'pragma') {\n        state.lastToken = state.lastToken + ' ' + cur;\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywords, cur)) {\n        if (cur === 'case' || cur === 'default') {\n            curPunc = 'case';\n        }\n        if (Object.prototype.propertyIsEnumerable.call(keywordsSpecial, cur)) {\n            state.lastToken = cur;\n        }\n        //if (cur === 'function' && state.para === 'parameterMode')\n        return 'keyword';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsEtherUnit, cur)) {\n        return 'etherUnit';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsContractRelated, cur)) {\n        return 'contractRelated';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsControlStructures, cur) ||\n        Object.prototype.propertyIsEnumerable.call(keywordsTypeInformation, cur) ||\n        Object.prototype.propertyIsEnumerable.call(keywordsV0505NewReserve, cur)) {\n        return 'keyword';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsValueTypes, cur) ||\n        Object.prototype.propertyIsEnumerable.call(keywordsTimeUnit, cur) ||\n        isValidInteger(cur) ||\n        isValidBytes(cur) ||\n        isValidFixed(cur)) {\n        state.lastToken += 'variable';\n        return 'keyword';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(atoms, cur)) {\n        return 'atom';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsErrorHandling, cur)) {\n        return 'errorHandling';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsMathematicalAndCryptographicFuctions, cur)) {\n        return 'mathematicalAndCryptographic';\n    }\n    if (Object.prototype.propertyIsEnumerable.call(keywordsMoreBlockAndTransactionProperties, cur) ||\n        (Object.prototype.propertyIsEnumerable.call(keywordsBlockAndTransactionProperties, cur) &&\n            keywordsBlockAndTransactionProperties[cur].some(function (item) {\n                return stream.match(`.${item}`);\n            }))) {\n        return 'variable-2';\n    }\n    if (cur === 'abi' &&\n        keywordsAbiEncodeDecodeFunctions[cur].some(function (item) {\n            return stream.match(`.${item}`);\n        })) {\n        return 'abi';\n    }\n    const style = updateHexLiterals(cur, stream);\n    if (style != null) {\n        return style;\n    }\n    if ((state.lastToken === 'functionName(' || state.lastToken === 'returns(') &&\n        Object.prototype.propertyIsEnumerable.call(keywordsContractList, cur)) {\n        state.lastToken += 'variable';\n        return 'variable';\n    }\n    if (state.lastToken === 'function') {\n        state.lastToken = 'functionName';\n        if (state.para == null) {\n            state.grammar = 'function';\n            state.para = '';\n        }\n        //state.parasMode = isNaN(state.parasMode) ? 1 : state.functionLayerCount++;\n        state.para += 'functionName';\n        return 'functionName';\n    }\n    if (state.lastToken === 'functionName(variable') {\n        state.lastToken = 'functionName(';\n        return 'parameterValue';\n    }\n    if (state.lastToken === 'returns(variable') {\n        state.lastToken = 'returns(';\n        return 'parameterValue';\n    }\n    if (state.lastToken === 'address' && cur === 'payable') {\n        state.lastToken = 'address payable';\n    }\n    if (state.lastToken === 'contract' || state.lastToken === 'struct') {\n        keywordsContractList[cur] = true;\n        state.lastToken = null;\n    }\n    if (state.grammar === 'function') {\n        return 'parameterValue';\n    }\n    return 'variable';\n}\nfunction tokenString(quote) {\n    return function (stream, state) {\n        let escaped = false;\n        let next;\n        let end = false;\n        next = stream.next();\n        while (next != null) {\n            if (next === quote && !escaped) {\n                end = true;\n                break;\n            }\n            escaped = !escaped && quote !== '`' && next === '\\\\';\n            next = stream.next();\n        }\n        if (end || !(escaped || quote === '`')) {\n            state.tokenize = tokenBase;\n        }\n        return 'string';\n    };\n}\nfunction tokenComment(stream, state) {\n    let maybeEnd = false;\n    let ch = stream.next();\n    while (ch) {\n        if (ch === '/' && maybeEnd) {\n            state.tokenize = tokenBase;\n            break;\n        }\n        maybeEnd = ch === '*';\n        ch = stream.next();\n    }\n    return 'comment';\n}\nfunction isVersion(stream, state) {\n    if (state.lastToken === 'pragma solidity') {\n        state.lastToken = null;\n        return (!state.startOfLine &&\n            (stream.match(/[\\^{0}][0-9.]+/) ||\n                stream.match(/[>=]+?[\\s]*[0-9.]+[\\s]*[<]?[\\s]*[0-9.]+/)));\n    }\n}\nfunction isNumber(ch, stream) {\n    if (/[\\d.]/.test(ch)) {\n        if (ch === '.') {\n            stream.match(/^[0-9]+([eE][-+]?[0-9]+)?/);\n        }\n        else if (ch === '0') {\n            if (!stream.match(/^[xX][0-9a-fA-F]+/)) {\n                stream.match(/^0[0-7]+/);\n            }\n        }\n        else {\n            stream.match(/^[0-9]*\\.?[0-9]*([eE][-+]?[0-9]+)?/);\n        }\n        return true;\n    }\n}\nfunction isValidInteger(token) {\n    if (token.match(/^[u]?int/)) {\n        if (token.indexOf('t') + 1 === token.length) {\n            return true;\n        }\n        const numberPart = Number(token.substr(token.indexOf('t') + 1, token.length));\n        return numberPart % 8 === 0 && numberPart <= 256;\n    }\n}\nfunction isValidBytes(token) {\n    if (token.match(/^bytes/)) {\n        if (token.indexOf('s') + 1 === token.length) {\n            return true;\n        }\n        const bytesPart = token.substr(token.indexOf('s') + 1, token.length);\n        return Number(bytesPart) <= 32;\n    }\n}\nfunction isValidFixed(token) {\n    if (token.match(/^[u]?fixed([0-9]+x[0-9]+)?/)) {\n        if (token.indexOf('d') + 1 === token.length) {\n            return true;\n        }\n        const numberPart = token\n            .substr(token.indexOf('d') + 1, token.length)\n            .split('x')\n            .map(Number);\n        return (numberPart[0] % 8 === 0 && numberPart[0] <= 256 && numberPart[1] <= 80);\n    }\n}\nfunction updateHexLiterals(token, stream) {\n    if (token.match(/^hex/) && stream.peek() === '\"') {\n        let maybeEnd = false;\n        let ch;\n        let hexValue = '';\n        let stringAfterHex = '';\n        ch = stream.next();\n        while (ch) {\n            stringAfterHex += ch;\n            if (ch === '\"' && maybeEnd) {\n                hexValue = stringAfterHex.substring(1, stringAfterHex.length - 1);\n                if (hexValue.match(/^[0-9a-fA-F]+$/)) {\n                    return 'number';\n                }\n                stream.backUp(stringAfterHex.length);\n                break;\n            }\n            maybeEnd = maybeEnd || ch === '\"';\n            ch = stream.next();\n        }\n    }\n}\nfunction updateGarmmer(ch, state) {\n    if (ch === ',' && state.para === 'functionName(variable') {\n        state.para = 'functionName(';\n    }\n    if (state.para != null && state.para.startsWith('functionName')) {\n        if (ch === ')') {\n            if (state.para.endsWith('(')) {\n                state.para = state.para.substr(0, state.para.length - 1);\n                if (state.para === 'functionName') {\n                    state.grammar = '';\n                }\n            }\n        }\n        else if (ch === '(') {\n            state.para += ch;\n        }\n    }\n    if (ch === '(' && state.lastToken === 'functionName') {\n        state.lastToken += ch;\n    }\n    else if (ch === ')' && state.lastToken === 'functionName(') {\n        state.lastToken = null;\n    }\n    else if (ch === '(' && state.lastToken === 'returns') {\n        state.lastToken += ch;\n    }\n    else if (ch === ')' &&\n        (state.lastToken === 'returns(' || state.lastToken === 'returns(variable')) {\n        state.lastToken = null;\n    }\n    if (ch === '(' && state.lastToken === 'address') {\n        state.lastToken += ch;\n    }\n    curPunc = ch;\n    return null;\n}\nclass Context {\n    constructor(indented, column, type, align, prev) {\n        this.indented = indented;\n        this.column = column;\n        this.type = type;\n        this.align = align;\n        this.prev = prev;\n    }\n}\nfunction pushContext(state, col, type) {\n    state.context = new Context(state.indented, col, type, null, state.context);\n    return state.context;\n}\nfunction popContext(state) {\n    if (!state.context.prev) {\n        return;\n    }\n    const t = state.context.type;\n    if (t === ')' || t === ']' || t === '}') {\n        state.indented = state.context.indented;\n    }\n    return (state.context = state.context.prev);\n}\nconst parser = {\n    startState(indentUnit) {\n        return {\n            tokenize: null,\n            context: new Context(0 - indentUnit, 0, 'top', false, null),\n            indented: 0,\n            startOfLine: true,\n            grammar: null,\n            lastToken: null,\n            para: null,\n        };\n    },\n    token(stream, state) {\n        const ctx = state.context;\n        if (stream.sol()) {\n            if (ctx.align == null) {\n                ctx.align = false;\n            }\n            state.indented = stream.indentation();\n            state.startOfLine = true;\n            if (ctx.type === 'case') {\n                ctx.type = '}';\n            }\n            if (state.grammar === 'doc') {\n                state.grammar = null;\n            }\n        }\n        if (stream.eatSpace()) {\n            return null;\n        }\n        curPunc = null;\n        const style = (state.tokenize || tokenBase)(stream, state);\n        if (style === 'comment') {\n            return style;\n        }\n        if (ctx.align == null) {\n            ctx.align = true;\n        }\n        if (curPunc === '{') {\n            pushContext(state, stream.column(), '}');\n        }\n        else if (curPunc === '[') {\n            pushContext(state, stream.column(), ']');\n        }\n        else if (curPunc === '(') {\n            pushContext(state, stream.column(), ')');\n        }\n        else if (curPunc === 'case') {\n            ctx.type = 'case';\n        }\n        else if (curPunc === '}' && ctx.type === '}') {\n            popContext(state);\n        }\n        else if (curPunc === ctx.type) {\n            popContext(state);\n        }\n        state.startOfLine = false;\n        return style;\n    },\n    indent(state, textAfter, indentContext) {\n        if (state.tokenize !== tokenBase && state.tokenize != null) {\n            return null;\n        }\n        const ctx = state.context;\n        const firstChar = textAfter && textAfter.charAt(0);\n        if (ctx.type === 'case' && /^(?:case|default)\\b/.test(textAfter)) {\n            state.context.type = '}';\n            return ctx.indented;\n        }\n        const closing = firstChar === ctx.type;\n        if (ctx.align) {\n            return ctx.column + (closing ? 0 : 1);\n        }\n        return ctx.indented + (closing ? 0 : indentContext.unit);\n    },\n    // @ts-ignore not specified in new stream parser, but maybe does something\n    electricChars: '{}):',\n    closeBrackets: '()[]{}\\'\\'\"\"``',\n    fold: 'brace',\n    blockCommentStart: '/*',\n    blockCommentEnd: '*/',\n    lineComment: '//',\n    tokenTable: {\n        functionName: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.Tag.define(),\n        parameterValue: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.Tag.define(),\n        addressFunction: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.Tag.define(),\n        errorHandling: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.Tag.define(),\n        contractRelated: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.Tag.define(),\n        version: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.Tag.define(),\n        etherUnit: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.Tag.define(),\n        doc: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.Tag.define(),\n        mathematicalAndCryptographic: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.Tag.define(),\n        abi: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.Tag.define(),\n    }\n};\nconst solidity = /*@__PURE__*/new _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LanguageSupport(/*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.StreamLanguage.define(parser));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlcGxpdC9jb2RlbWlycm9yLWxhbmctc29saWRpdHkvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVFO0FBQ2hDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxLQUFLO0FBQ3pDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsRUFBRTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQjtBQUN0QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpREFBRztBQUN0QyxxQ0FBcUMsaURBQUc7QUFDeEMsc0NBQXNDLGlEQUFHO0FBQ3pDLG9DQUFvQyxpREFBRztBQUN2QyxzQ0FBc0MsaURBQUc7QUFDekMsOEJBQThCLGlEQUFHO0FBQ2pDLGdDQUFnQyxpREFBRztBQUNuQywwQkFBMEIsaURBQUc7QUFDN0IsbURBQW1ELGlEQUFHO0FBQ3RELDBCQUEwQixpREFBRztBQUM3QjtBQUNBO0FBQ0Esa0NBQWtDLGlFQUFlLGNBQWMsZ0VBQWM7O0FBRWpEIiwic291cmNlcyI6WyIvVXNlcnMvam9yZGFuc29sb21vbi9EZXNrdG9wL1dlYjMvRGV2ZWxvcG1lbnQvTWluZHMzdC1HYW1lL2Zyb250LWVuZC9ub2RlX21vZHVsZXMvQHJlcGxpdC9jb2RlbWlycm9yLWxhbmctc29saWRpdHkvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5ndWFnZVN1cHBvcnQsIFN0cmVhbUxhbmd1YWdlIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5cbi8qKlxuKiBXcmFwcGVyIGFyb3VuZCB0aGUgbGVnYWN5IENNNSBTb2xpZGl0eSBsYW5ndWFnZSBtb2RlXG4qIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FsaW5jb2RlL2NvZGVtaXJyb3Itc29saWRpdHlcbiovXG5jb25zdCBrZXl3b3JkcyA9IHtcbiAgICBwcmFnbWE6IHRydWUsXG4gICAgc29saWRpdHk6IHRydWUsXG4gICAgaW1wb3J0OiB0cnVlLFxuICAgIGFzOiB0cnVlLFxuICAgIGZyb206IHRydWUsXG4gICAgY29udHJhY3Q6IHRydWUsXG4gICAgY29uc3RydWN0b3I6IHRydWUsXG4gICAgaXM6IHRydWUsXG4gICAgZnVuY3Rpb246IHRydWUsXG4gICAgbW9kaWZpZXI6IHRydWUsXG4gICAgLy8gbW9kaWZpZXJzXG4gICAgcHVyZTogdHJ1ZSxcbiAgICB2aWV3OiB0cnVlLFxuICAgIHBheWFibGU6IHRydWUsXG4gICAgY29uc3RhbnQ6IHRydWUsXG4gICAgYW5vbnltb3VzOiB0cnVlLFxuICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgcmV0dXJuczogdHJ1ZSxcbiAgICByZXR1cm46IHRydWUsXG4gICAgZXZlbnQ6IHRydWUsXG4gICAgc3RydWN0OiB0cnVlLFxuICAgIG1hcHBpbmc6IHRydWUsXG4gICAgaW50ZXJmYWNlOiB0cnVlLFxuICAgIHVzaW5nOiB0cnVlLFxuICAgIGxpYnJhcnk6IHRydWUsXG4gICAgc3RvcmFnZTogdHJ1ZSxcbiAgICBtZW1vcnk6IHRydWUsXG4gICAgY2FsbGRhdGE6IHRydWUsXG4gICAgcHVibGljOiB0cnVlLFxuICAgIHByaXZhdGU6IHRydWUsXG4gICAgZXh0ZXJuYWw6IHRydWUsXG4gICAgaW50ZXJuYWw6IHRydWUsXG4gICAgZW1pdDogdHJ1ZSxcbiAgICBhc3NlbWJseTogdHJ1ZSxcbiAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICBhZnRlcjogdHJ1ZSxcbiAgICBjYXRjaDogdHJ1ZSxcbiAgICBmaW5hbDogdHJ1ZSxcbiAgICBpbjogdHJ1ZSxcbiAgICBpbmxpbmU6IHRydWUsXG4gICAgbGV0OiB0cnVlLFxuICAgIG1hdGNoOiB0cnVlLFxuICAgIG51bGw6IHRydWUsXG4gICAgb2Y6IHRydWUsXG4gICAgcmVsb2NhdGFibGU6IHRydWUsXG4gICAgc3RhdGljOiB0cnVlLFxuICAgIHRyeTogdHJ1ZSxcbiAgICB0eXBlb2Y6IHRydWUsXG4gICAgdmFyOiB0cnVlLFxufTtcbmNvbnN0IGtleXdvcmRzU3BlY2lhbCA9IHtcbiAgICBwcmFnbWE6IHRydWUsXG4gICAgcmV0dXJuczogdHJ1ZSxcbiAgICBhZGRyZXNzOiB0cnVlLFxuICAgIGNvbnRyYWN0OiB0cnVlLFxuICAgIGZ1bmN0aW9uOiB0cnVlLFxuICAgIHN0cnVjdDogdHJ1ZSxcbn07XG5jb25zdCBrZXl3b3Jkc0V0aGVyVW5pdCA9IHtcbiAgICB3ZWk6IHRydWUsXG4gICAgc3phYm86IHRydWUsXG4gICAgZmlubmV5OiB0cnVlLFxuICAgIGV0aGVyOiB0cnVlLFxufTtcbmNvbnN0IGtleXdvcmRzVGltZVVuaXQgPSB7XG4gICAgc2Vjb25kczogdHJ1ZSxcbiAgICBtaW51dGVzOiB0cnVlLFxuICAgIGhvdXJzOiB0cnVlLFxuICAgIGRheXM6IHRydWUsXG4gICAgd2Vla3M6IHRydWUsXG59O1xuY29uc3Qga2V5d29yZHNCbG9ja0FuZFRyYW5zYWN0aW9uUHJvcGVydGllcyA9IHtcbiAgICBibG9jazogWydjb2luYmFzZScsICdkaWZmaWN1bHR5JywgJ2dhc2xpbWl0JywgJ251bWJlcicsICd0aW1lc3RhbXAnXSxcbiAgICBtc2c6IFsnZGF0YScsICdzZW5kZXInLCAnc2lnJywgJ3ZhbHVlJ10sXG4gICAgdHg6IFsnZ2FzcHJpY2UnLCAnb3JpZ2luJ10sXG59O1xuY29uc3Qga2V5d29yZHNNb3JlQmxvY2tBbmRUcmFuc2FjdGlvblByb3BlcnRpZXMgPSB7XG4gICAgbm93OiB0cnVlLFxuICAgIGdhc2xlZnQ6IHRydWUsXG4gICAgYmxvY2toYXNoOiB0cnVlLFxufTtcbmNvbnN0IGtleXdvcmRzRXJyb3JIYW5kbGluZyA9IHtcbiAgICBhc3NlcnQ6IHRydWUsXG4gICAgcmVxdWlyZTogdHJ1ZSxcbiAgICByZXZlcnQ6IHRydWUsXG4gICAgdGhyb3c6IHRydWUsXG59O1xuY29uc3Qga2V5d29yZHNNYXRoZW1hdGljYWxBbmRDcnlwdG9ncmFwaGljRnVjdGlvbnMgPSB7XG4gICAgYWRkbW9kOiB0cnVlLFxuICAgIG11bG1vZDogdHJ1ZSxcbiAgICBrZWNjYWsyNTY6IHRydWUsXG4gICAgc2hhMjU2OiB0cnVlLFxuICAgIHJpcGVtZDE2MDogdHJ1ZSxcbiAgICBlY3JlY292ZXI6IHRydWUsXG59O1xuY29uc3Qga2V5d29yZHNDb250cmFjdFJlbGF0ZWQgPSB7XG4gICAgdGhpczogdHJ1ZSxcbiAgICBzZWxmZGVzdHJ1Y3Q6IHRydWUsXG4gICAgc3VwZXI6IHRydWUsXG59O1xuY29uc3Qga2V5d29yZHNUeXBlSW5mb3JtYXRpb24gPSB7IHR5cGU6IHRydWUgfTtcbmNvbnN0IGtleXdvcmRzQ29udHJhY3RMaXN0ID0ge307XG5jb25zdCBrZXl3b3Jkc0NvbnRyb2xTdHJ1Y3R1cmVzID0ge1xuICAgIGlmOiB0cnVlLFxuICAgIGVsc2U6IHRydWUsXG4gICAgd2hpbGU6IHRydWUsXG4gICAgZG86IHRydWUsXG4gICAgZm9yOiB0cnVlLFxuICAgIGJyZWFrOiB0cnVlLFxuICAgIGNvbnRpbnVlOiB0cnVlLFxuICAgIHN3aXRjaDogdHJ1ZSxcbiAgICBjYXNlOiB0cnVlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG59O1xuY29uc3Qga2V5d29yZHNWYWx1ZVR5cGVzID0ge1xuICAgIGJvb2w6IHRydWUsXG4gICAgYnl0ZTogdHJ1ZSxcbiAgICBzdHJpbmc6IHRydWUsXG4gICAgZW51bTogdHJ1ZSxcbiAgICBhZGRyZXNzOiB0cnVlLFxufTtcbmNvbnN0IGtleXdvcmRzVjA1MDVOZXdSZXNlcnZlID0ge1xuICAgIGFsaWFzOiB0cnVlLFxuICAgIGFwcGx5OiB0cnVlLFxuICAgIGF1dG86IHRydWUsXG4gICAgY29weW9mOiB0cnVlLFxuICAgIGRlZmluZTogdHJ1ZSxcbiAgICBpbW11dGFibGU6IHRydWUsXG4gICAgaW1wbGVtZW50czogdHJ1ZSxcbiAgICBtYWNybzogdHJ1ZSxcbiAgICBtdXRhYmxlOiB0cnVlLFxuICAgIG92ZXJyaWRlOiB0cnVlLFxuICAgIHBhcnRpYWw6IHRydWUsXG4gICAgcHJvbWlzZTogdHJ1ZSxcbiAgICByZWZlcmVuY2U6IHRydWUsXG4gICAgc2VhbGVkOiB0cnVlLFxuICAgIHNpemVvZjogdHJ1ZSxcbiAgICBzdXBwb3J0czogdHJ1ZSxcbiAgICB0eXBlZGVmOiB0cnVlLFxuICAgIHVuY2hlY2tlZDogdHJ1ZSxcbn07XG5jb25zdCBrZXl3b3Jkc0FiaUVuY29kZURlY29kZUZ1bmN0aW9ucyA9IHtcbiAgICBhYmk6IFtcbiAgICAgICAgJ2RlY29kZScsXG4gICAgICAgICdlbmNvZGVQYWNrZWQnLFxuICAgICAgICAnZW5jb2RlV2l0aFNlbGVjdG9yJyxcbiAgICAgICAgJ2VuY29kZVdpdGhTaWduYXR1cmUnLFxuICAgICAgICAnZW5jb2RlJyxcbiAgICBdLFxufTtcbmNvbnN0IGtleXdvcmRzTWVtYmVyc09mQWRkcmVzc1R5cGUgPSBbXG4gICAgJ3RyYW5zZmVyJyxcbiAgICAnc2VuZCcsXG4gICAgJ2JhbGFuY2UnLFxuICAgICdjYWxsJyxcbiAgICAnZGVsZWdhdGVjYWxsJyxcbiAgICAnc3RhdGljY2FsbCcsXG5dO1xuY29uc3QgbmF0U3BlY1RhZ3MgPSBbJ3RpdGxlJywgJ2F1dGhvcicsICdub3RpY2UnLCAnZGV2JywgJ3BhcmFtJywgJ3JldHVybiddO1xuY29uc3QgYXRvbXMgPSB7XG4gICAgZGVsZXRlOiB0cnVlLFxuICAgIG5ldzogdHJ1ZSxcbiAgICB0cnVlOiB0cnVlLFxuICAgIGZhbHNlOiB0cnVlLFxufTtcbmNvbnN0IGlzT3BlcmF0b3JDaGFyID0gL1srXFwtKiZeJTo9PD4hfC9+XS87XG5jb25zdCBpc05lZ2F0aXZlQ2hhciA9IC9bLV0vO1xubGV0IGN1clB1bmM7XG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGxldCBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIiB8fCBjaCA9PT0gJ2AnKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChpc1ZlcnNpb24oc3RyZWFtLCBzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuICd2ZXJzaW9uJztcbiAgICB9XG4gICAgaWYgKGNoID09PSAnLicgJiZcbiAgICAgICAga2V5d29yZHNNZW1iZXJzT2ZBZGRyZXNzVHlwZS5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtLm1hdGNoKGAke2l0ZW19YCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiAnYWRkcmVzc0Z1bmN0aW9uJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaCA9PT0gJ3N0cmluZycgJiYgaXNOdW1iZXIoY2gsIHN0cmVhbSkpIHtcbiAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoID09PSAnc3RyaW5nJyAmJiAvW1tcXF17fSgpLDs6Ll0vLnRlc3QoY2gpKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVHYXJtbWVyKGNoLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KCcqJykpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXC97Mn0vKSkge1xuICAgICAgICAgICAgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ3JhbW1hciA9ICdkb2MnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KCcvJykpIHtcbiAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaCA9PT0gJ3N0cmluZycgJiYgaXNOZWdhdGl2ZUNoYXIudGVzdChjaCkpIHtcbiAgICAgICAgY29uc3QgcGVla2VkID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwZWVrZWQgPT09ICdzdHJpbmcnICYmIGlzTnVtYmVyKHBlZWtlZCwgc3RyZWFtKSkge1xuICAgICAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnb3BlcmF0b3InO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoID09PSAnc3RyaW5nJyAmJiBpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgICAgICByZXR1cm4gJ29wZXJhdG9yJztcbiAgICB9XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3JF9cXHhhMS1cXHVmZmZmXS8pO1xuICAgIGNvbnN0IGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgaWYgKHN0YXRlLmdyYW1tYXIgPT09ICdkb2MnKSB7XG4gICAgICAgIGlmIChuYXRTcGVjVGFncy5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyID09PSBgQCR7aXRlbX1gO1xuICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuICdkb2NSZXNlcnZlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgfVxuICAgIGlmIChjdXIgPT09ICdzb2xpZGl0eScgJiYgc3RhdGUubGFzdFRva2VuID09PSAncHJhZ21hJykge1xuICAgICAgICBzdGF0ZS5sYXN0VG9rZW4gPSBzdGF0ZS5sYXN0VG9rZW4gKyAnICcgKyBjdXI7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoa2V5d29yZHMsIGN1cikpIHtcbiAgICAgICAgaWYgKGN1ciA9PT0gJ2Nhc2UnIHx8IGN1ciA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBjdXJQdW5jID0gJ2Nhc2UnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoa2V5d29yZHNTcGVjaWFsLCBjdXIpKSB7XG4gICAgICAgICAgICBzdGF0ZS5sYXN0VG9rZW4gPSBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgLy9pZiAoY3VyID09PSAnZnVuY3Rpb24nICYmIHN0YXRlLnBhcmEgPT09ICdwYXJhbWV0ZXJNb2RlJylcbiAgICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChrZXl3b3Jkc0V0aGVyVW5pdCwgY3VyKSkge1xuICAgICAgICByZXR1cm4gJ2V0aGVyVW5pdCc7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoa2V5d29yZHNDb250cmFjdFJlbGF0ZWQsIGN1cikpIHtcbiAgICAgICAgcmV0dXJuICdjb250cmFjdFJlbGF0ZWQnO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGtleXdvcmRzQ29udHJvbFN0cnVjdHVyZXMsIGN1cikgfHxcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGtleXdvcmRzVHlwZUluZm9ybWF0aW9uLCBjdXIpIHx8XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChrZXl3b3Jkc1YwNTA1TmV3UmVzZXJ2ZSwgY3VyKSkge1xuICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGtleXdvcmRzVmFsdWVUeXBlcywgY3VyKSB8fFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoa2V5d29yZHNUaW1lVW5pdCwgY3VyKSB8fFxuICAgICAgICBpc1ZhbGlkSW50ZWdlcihjdXIpIHx8XG4gICAgICAgIGlzVmFsaWRCeXRlcyhjdXIpIHx8XG4gICAgICAgIGlzVmFsaWRGaXhlZChjdXIpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RUb2tlbiArPSAndmFyaWFibGUnO1xuICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGF0b21zLCBjdXIpKSB7XG4gICAgICAgIHJldHVybiAnYXRvbSc7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoa2V5d29yZHNFcnJvckhhbmRsaW5nLCBjdXIpKSB7XG4gICAgICAgIHJldHVybiAnZXJyb3JIYW5kbGluZyc7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoa2V5d29yZHNNYXRoZW1hdGljYWxBbmRDcnlwdG9ncmFwaGljRnVjdGlvbnMsIGN1cikpIHtcbiAgICAgICAgcmV0dXJuICdtYXRoZW1hdGljYWxBbmRDcnlwdG9ncmFwaGljJztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChrZXl3b3Jkc01vcmVCbG9ja0FuZFRyYW5zYWN0aW9uUHJvcGVydGllcywgY3VyKSB8fFxuICAgICAgICAoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGtleXdvcmRzQmxvY2tBbmRUcmFuc2FjdGlvblByb3BlcnRpZXMsIGN1cikgJiZcbiAgICAgICAgICAgIGtleXdvcmRzQmxvY2tBbmRUcmFuc2FjdGlvblByb3BlcnRpZXNbY3VyXS5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS5tYXRjaChgLiR7aXRlbX1gKTtcbiAgICAgICAgICAgIH0pKSkge1xuICAgICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgIH1cbiAgICBpZiAoY3VyID09PSAnYWJpJyAmJlxuICAgICAgICBrZXl3b3Jkc0FiaUVuY29kZURlY29kZUZ1bmN0aW9uc1tjdXJdLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW0ubWF0Y2goYC4ke2l0ZW19YCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiAnYWJpJztcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSB1cGRhdGVIZXhMaXRlcmFscyhjdXIsIHN0cmVhbSk7XG4gICAgaWYgKHN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgICBpZiAoKHN0YXRlLmxhc3RUb2tlbiA9PT0gJ2Z1bmN0aW9uTmFtZSgnIHx8IHN0YXRlLmxhc3RUb2tlbiA9PT0gJ3JldHVybnMoJykgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGtleXdvcmRzQ29udHJhY3RMaXN0LCBjdXIpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RUb2tlbiArPSAndmFyaWFibGUnO1xuICAgICAgICByZXR1cm4gJ3ZhcmlhYmxlJztcbiAgICB9XG4gICAgaWYgKHN0YXRlLmxhc3RUb2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGF0ZS5sYXN0VG9rZW4gPSAnZnVuY3Rpb25OYW1lJztcbiAgICAgICAgaWYgKHN0YXRlLnBhcmEgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUuZ3JhbW1hciA9ICdmdW5jdGlvbic7XG4gICAgICAgICAgICBzdGF0ZS5wYXJhID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy9zdGF0ZS5wYXJhc01vZGUgPSBpc05hTihzdGF0ZS5wYXJhc01vZGUpID8gMSA6IHN0YXRlLmZ1bmN0aW9uTGF5ZXJDb3VudCsrO1xuICAgICAgICBzdGF0ZS5wYXJhICs9ICdmdW5jdGlvbk5hbWUnO1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uTmFtZSc7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5sYXN0VG9rZW4gPT09ICdmdW5jdGlvbk5hbWUodmFyaWFibGUnKSB7XG4gICAgICAgIHN0YXRlLmxhc3RUb2tlbiA9ICdmdW5jdGlvbk5hbWUoJztcbiAgICAgICAgcmV0dXJuICdwYXJhbWV0ZXJWYWx1ZSc7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5sYXN0VG9rZW4gPT09ICdyZXR1cm5zKHZhcmlhYmxlJykge1xuICAgICAgICBzdGF0ZS5sYXN0VG9rZW4gPSAncmV0dXJucygnO1xuICAgICAgICByZXR1cm4gJ3BhcmFtZXRlclZhbHVlJztcbiAgICB9XG4gICAgaWYgKHN0YXRlLmxhc3RUb2tlbiA9PT0gJ2FkZHJlc3MnICYmIGN1ciA9PT0gJ3BheWFibGUnKSB7XG4gICAgICAgIHN0YXRlLmxhc3RUb2tlbiA9ICdhZGRyZXNzIHBheWFibGUnO1xuICAgIH1cbiAgICBpZiAoc3RhdGUubGFzdFRva2VuID09PSAnY29udHJhY3QnIHx8IHN0YXRlLmxhc3RUb2tlbiA9PT0gJ3N0cnVjdCcpIHtcbiAgICAgICAga2V5d29yZHNDb250cmFjdExpc3RbY3VyXSA9IHRydWU7XG4gICAgICAgIHN0YXRlLmxhc3RUb2tlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5ncmFtbWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAncGFyYW1ldGVyVmFsdWUnO1xuICAgIH1cbiAgICByZXR1cm4gJ3ZhcmlhYmxlJztcbn1cbmZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBuZXh0O1xuICAgICAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgICAgIG5leHQgPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIHF1b3RlICE9PSAnYCcgJiYgbmV4dCA9PT0gJ1xcXFwnO1xuICAgICAgICAgICAgbmV4dCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCB8fCAhKGVzY2FwZWQgfHwgcXVvdGUgPT09ICdgJykpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBsZXQgbWF5YmVFbmQgPSBmYWxzZTtcbiAgICBsZXQgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIHdoaWxlIChjaCkge1xuICAgICAgICBpZiAoY2ggPT09ICcvJyAmJiBtYXliZUVuZCkge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXliZUVuZCA9IGNoID09PSAnKic7XG4gICAgICAgIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuICdjb21tZW50Jztcbn1cbmZ1bmN0aW9uIGlzVmVyc2lvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmxhc3RUb2tlbiA9PT0gJ3ByYWdtYSBzb2xpZGl0eScpIHtcbiAgICAgICAgc3RhdGUubGFzdFRva2VuID0gbnVsbDtcbiAgICAgICAgcmV0dXJuICghc3RhdGUuc3RhcnRPZkxpbmUgJiZcbiAgICAgICAgICAgIChzdHJlYW0ubWF0Y2goL1tcXF57MH1dWzAtOS5dKy8pIHx8XG4gICAgICAgICAgICAgICAgc3RyZWFtLm1hdGNoKC9bPj1dKz9bXFxzXSpbMC05Ll0rW1xcc10qWzxdP1tcXHNdKlswLTkuXSsvKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKGNoLCBzdHJlYW0pIHtcbiAgICBpZiAoL1tcXGQuXS8udGVzdChjaCkpIHtcbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIHN0cmVhbS5tYXRjaCgvXlswLTldKyhbZUVdWy0rXT9bMC05XSspPy8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnMCcpIHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLm1hdGNoKC9eW3hYXVswLTlhLWZBLUZdKy8pKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm1hdGNoKC9eMFswLTddKy8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLm1hdGNoKC9eWzAtOV0qXFwuP1swLTldKihbZUVdWy0rXT9bMC05XSspPy8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRJbnRlZ2VyKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLm1hdGNoKC9eW3VdP2ludC8pKSB7XG4gICAgICAgIGlmICh0b2tlbi5pbmRleE9mKCd0JykgKyAxID09PSB0b2tlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bWJlclBhcnQgPSBOdW1iZXIodG9rZW4uc3Vic3RyKHRva2VuLmluZGV4T2YoJ3QnKSArIDEsIHRva2VuLmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gbnVtYmVyUGFydCAlIDggPT09IDAgJiYgbnVtYmVyUGFydCA8PSAyNTY7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZEJ5dGVzKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLm1hdGNoKC9eYnl0ZXMvKSkge1xuICAgICAgICBpZiAodG9rZW4uaW5kZXhPZigncycpICsgMSA9PT0gdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlc1BhcnQgPSB0b2tlbi5zdWJzdHIodG9rZW4uaW5kZXhPZigncycpICsgMSwgdG9rZW4ubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIE51bWJlcihieXRlc1BhcnQpIDw9IDMyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRGaXhlZCh0b2tlbikge1xuICAgIGlmICh0b2tlbi5tYXRjaCgvXlt1XT9maXhlZChbMC05XSt4WzAtOV0rKT8vKSkge1xuICAgICAgICBpZiAodG9rZW4uaW5kZXhPZignZCcpICsgMSA9PT0gdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1iZXJQYXJ0ID0gdG9rZW5cbiAgICAgICAgICAgIC5zdWJzdHIodG9rZW4uaW5kZXhPZignZCcpICsgMSwgdG9rZW4ubGVuZ3RoKVxuICAgICAgICAgICAgLnNwbGl0KCd4JylcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIChudW1iZXJQYXJ0WzBdICUgOCA9PT0gMCAmJiBudW1iZXJQYXJ0WzBdIDw9IDI1NiAmJiBudW1iZXJQYXJ0WzFdIDw9IDgwKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVIZXhMaXRlcmFscyh0b2tlbiwgc3RyZWFtKSB7XG4gICAgaWYgKHRva2VuLm1hdGNoKC9eaGV4LykgJiYgc3RyZWFtLnBlZWsoKSA9PT0gJ1wiJykge1xuICAgICAgICBsZXQgbWF5YmVFbmQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICBsZXQgaGV4VmFsdWUgPSAnJztcbiAgICAgICAgbGV0IHN0cmluZ0FmdGVySGV4ID0gJyc7XG4gICAgICAgIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICBzdHJpbmdBZnRlckhleCArPSBjaDtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJyAmJiBtYXliZUVuZCkge1xuICAgICAgICAgICAgICAgIGhleFZhbHVlID0gc3RyaW5nQWZ0ZXJIZXguc3Vic3RyaW5nKDEsIHN0cmluZ0FmdGVySGV4Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChoZXhWYWx1ZS5tYXRjaCgvXlswLTlhLWZBLUZdKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmVhbS5iYWNrVXAoc3RyaW5nQWZ0ZXJIZXgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1heWJlRW5kID0gbWF5YmVFbmQgfHwgY2ggPT09ICdcIic7XG4gICAgICAgICAgICBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVHYXJtbWVyKGNoLCBzdGF0ZSkge1xuICAgIGlmIChjaCA9PT0gJywnICYmIHN0YXRlLnBhcmEgPT09ICdmdW5jdGlvbk5hbWUodmFyaWFibGUnKSB7XG4gICAgICAgIHN0YXRlLnBhcmEgPSAnZnVuY3Rpb25OYW1lKCc7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5wYXJhICE9IG51bGwgJiYgc3RhdGUucGFyYS5zdGFydHNXaXRoKCdmdW5jdGlvbk5hbWUnKSkge1xuICAgICAgICBpZiAoY2ggPT09ICcpJykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnBhcmEuZW5kc1dpdGgoJygnKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnBhcmEgPSBzdGF0ZS5wYXJhLnN1YnN0cigwLCBzdGF0ZS5wYXJhLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5wYXJhID09PSAnZnVuY3Rpb25OYW1lJykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ncmFtbWFyID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgICAgIHN0YXRlLnBhcmEgKz0gY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoID09PSAnKCcgJiYgc3RhdGUubGFzdFRva2VuID09PSAnZnVuY3Rpb25OYW1lJykge1xuICAgICAgICBzdGF0ZS5sYXN0VG9rZW4gKz0gY2g7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoID09PSAnKScgJiYgc3RhdGUubGFzdFRva2VuID09PSAnZnVuY3Rpb25OYW1lKCcpIHtcbiAgICAgICAgc3RhdGUubGFzdFRva2VuID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2ggPT09ICcoJyAmJiBzdGF0ZS5sYXN0VG9rZW4gPT09ICdyZXR1cm5zJykge1xuICAgICAgICBzdGF0ZS5sYXN0VG9rZW4gKz0gY2g7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoID09PSAnKScgJiZcbiAgICAgICAgKHN0YXRlLmxhc3RUb2tlbiA9PT0gJ3JldHVybnMoJyB8fCBzdGF0ZS5sYXN0VG9rZW4gPT09ICdyZXR1cm5zKHZhcmlhYmxlJykpIHtcbiAgICAgICAgc3RhdGUubGFzdFRva2VuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNoID09PSAnKCcgJiYgc3RhdGUubGFzdFRva2VuID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgc3RhdGUubGFzdFRva2VuICs9IGNoO1xuICAgIH1cbiAgICBjdXJQdW5jID0gY2g7XG4gICAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBhbGlnbiwgcHJldikge1xuICAgICAgICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIGNvbCwgdHlwZSkge1xuICAgIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChzdGF0ZS5pbmRlbnRlZCwgY29sLCB0eXBlLCBudWxsLCBzdGF0ZS5jb250ZXh0KTtcbiAgICByZXR1cm4gc3RhdGUuY29udGV4dDtcbn1cbmZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLmNvbnRleHQucHJldikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHQgPSBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gICAgaWYgKHQgPT09ICcpJyB8fCB0ID09PSAnXScgfHwgdCA9PT0gJ30nKSB7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RhdGUuY29udGV4dC5pbmRlbnRlZDtcbiAgICB9XG4gICAgcmV0dXJuIChzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2KTtcbn1cbmNvbnN0IHBhcnNlciA9IHtcbiAgICBzdGFydFN0YXRlKGluZGVudFVuaXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuaXplOiBudWxsLFxuICAgICAgICAgICAgY29udGV4dDogbmV3IENvbnRleHQoMCAtIGluZGVudFVuaXQsIDAsICd0b3AnLCBmYWxzZSwgbnVsbCksXG4gICAgICAgICAgICBpbmRlbnRlZDogMCxcbiAgICAgICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlLFxuICAgICAgICAgICAgZ3JhbW1hcjogbnVsbCxcbiAgICAgICAgICAgIGxhc3RUb2tlbjogbnVsbCxcbiAgICAgICAgICAgIHBhcmE6IG51bGwsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b2tlbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjdHgudHlwZSA9PT0gJ2Nhc2UnKSB7XG4gICAgICAgICAgICAgICAgY3R4LnR5cGUgPSAnfSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZ3JhbW1hciA9PT0gJ2RvYycpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ncmFtbWFyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGN1clB1bmMgPSBudWxsO1xuICAgICAgICBjb25zdCBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3R5bGUgPT09ICdjb21tZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LmFsaWduID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyUHVuYyA9PT0gJ3snKSB7XG4gICAgICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCAnfScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT09ICdbJykge1xuICAgICAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgJ10nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJQdW5jID09PSAnKCcpIHtcbiAgICAgICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PT0gJ2Nhc2UnKSB7XG4gICAgICAgICAgICBjdHgudHlwZSA9ICdjYXNlJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJQdW5jID09PSAnfScgJiYgY3R4LnR5cGUgPT09ICd9Jykge1xuICAgICAgICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PT0gY3R4LnR5cGUpIHtcbiAgICAgICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuICAgIGluZGVudChzdGF0ZSwgdGV4dEFmdGVyLCBpbmRlbnRDb250ZXh0KSB7XG4gICAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPT0gdG9rZW5CYXNlICYmIHN0YXRlLnRva2VuaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApO1xuICAgICAgICBpZiAoY3R4LnR5cGUgPT09ICdjYXNlJyAmJiAvXig/OmNhc2V8ZGVmYXVsdClcXGIvLnRlc3QodGV4dEFmdGVyKSkge1xuICAgICAgICAgICAgc3RhdGUuY29udGV4dC50eXBlID0gJ30nO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5pbmRlbnRlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9zaW5nID0gZmlyc3RDaGFyID09PSBjdHgudHlwZTtcbiAgICAgICAgaWYgKGN0eC5hbGlnbikge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaW5kZW50Q29udGV4dC51bml0KTtcbiAgICB9LFxuICAgIC8vIEB0cy1pZ25vcmUgbm90IHNwZWNpZmllZCBpbiBuZXcgc3RyZWFtIHBhcnNlciwgYnV0IG1heWJlIGRvZXMgc29tZXRoaW5nXG4gICAgZWxlY3RyaWNDaGFyczogJ3t9KTonLFxuICAgIGNsb3NlQnJhY2tldHM6ICcoKVtde31cXCdcXCdcIlwiYGAnLFxuICAgIGZvbGQ6ICdicmFjZScsXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6ICcvKicsXG4gICAgYmxvY2tDb21tZW50RW5kOiAnKi8nLFxuICAgIGxpbmVDb21tZW50OiAnLy8nLFxuICAgIHRva2VuVGFibGU6IHtcbiAgICAgICAgZnVuY3Rpb25OYW1lOiAvKkBfX1BVUkVfXyovVGFnLmRlZmluZSgpLFxuICAgICAgICBwYXJhbWV0ZXJWYWx1ZTogLypAX19QVVJFX18qL1RhZy5kZWZpbmUoKSxcbiAgICAgICAgYWRkcmVzc0Z1bmN0aW9uOiAvKkBfX1BVUkVfXyovVGFnLmRlZmluZSgpLFxuICAgICAgICBlcnJvckhhbmRsaW5nOiAvKkBfX1BVUkVfXyovVGFnLmRlZmluZSgpLFxuICAgICAgICBjb250cmFjdFJlbGF0ZWQ6IC8qQF9fUFVSRV9fKi9UYWcuZGVmaW5lKCksXG4gICAgICAgIHZlcnNpb246IC8qQF9fUFVSRV9fKi9UYWcuZGVmaW5lKCksXG4gICAgICAgIGV0aGVyVW5pdDogLypAX19QVVJFX18qL1RhZy5kZWZpbmUoKSxcbiAgICAgICAgZG9jOiAvKkBfX1BVUkVfXyovVGFnLmRlZmluZSgpLFxuICAgICAgICBtYXRoZW1hdGljYWxBbmRDcnlwdG9ncmFwaGljOiAvKkBfX1BVUkVfXyovVGFnLmRlZmluZSgpLFxuICAgICAgICBhYmk6IC8qQF9fUFVSRV9fKi9UYWcuZGVmaW5lKCksXG4gICAgfVxufTtcbmNvbnN0IHNvbGlkaXR5ID0gLypAX19QVVJFX18qL25ldyBMYW5ndWFnZVN1cHBvcnQoLypAX19QVVJFX18qL1N0cmVhbUxhbmd1YWdlLmRlZmluZShwYXJzZXIpKTtcblxuZXhwb3J0IHsgcGFyc2VyLCBzb2xpZGl0eSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@replit/codemirror-lang-solidity/dist/index.js\n"));

/***/ })

});